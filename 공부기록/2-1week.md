# 핵심 말씀
## 엔티티는?
- 엔티티는 최대한 순수하게, 핵심 비지니스 로직에만 디펜던시가 있어야한다.
- 그래야 서비스가 커지면 유지보수가 편하다.
- 화면에 대한 로직은 없어야한다.
- 화면에 맞는 것은 폼개체, DTO사용한다.
- API를 만들 때는 절대 엔티티를 외부로 반환하면 안된다. API라는 것은 스팩? 이다.

## 변경 감지와 병합
### 준영속 엔티티
- 원래 변경감지륾 해서 (더티체킹 - 플러시때) 알아서 커밋
- 그러니깐 업데이트 쿼리를 안념겨도 값을 가져와서 바꾸면 jpa가 바뀌었네? 트랜잭션 커밋 시점에 알아서 날림
- 문제는 준영속 엔티티 때 생긴다.
- 아이템컨트롤러에서 업데이트 아이템은 한번 jpa가 관리를 했던 것임(form으로)
- 왜냐하면 Id기반으로 이미 데베에 다녀온 친구, 그래서 준영속 엔티티임
- 여기서 book이 준영속 엔티티
- 준영속 엔티티는 jpa가 관리를 안하기 때문에 더티체킹을 안한다.
- 그래서 DB업데이트를 안한다.
***
### 준영속 엔티티 저장 두가지 방법
### 영속 상태 꺼내오기
```java
@Transactional
void update(Item itemParam) { //itemParam: 파리미터로 넘어온 준영속 상태의 엔티티
Item findItem = em.find(Item.class, itemParam.getId()); //같은 엔티티를 조회한다.
findItem.setPrice(itemParam.getPrice()); //데이터를 수정한다. }
```
여기서는 데이터베이스에 있는 아이템을 꺼내온 영속상태의 엔티티이기 때문에 알아서 커밋시 플러시함.
그래서 자동으로 더티체킹

### 머지
```java
@Transactional
void update(Item itemParam) { //itemParam: 파리미터로 넘어온 준영속 상태의 엔티티 Item mergeItem = em.merge(itemParam);
}
```
머지는 쉽게 말해서 위를 한번에 해주는 거
그러나 파라미터로 넘어온 item과 머지의 내용물은 다른것
머지된 내용물은 영속상태, 파라미터로 넘어온 item은 아님
- 그러나 병합은 모든 속성은 다 갈아지고, 변경 감지 기능을 쓰면 원하는 값만 쓸 수 있다.
- 그러니깐 값을 다 넣지 않고 머지를 하게되면 넣지 않은 값은 null로 변경됨 -> 매우 위험
- 그래서 최대한 머지를 사용하지 않는다~
***
## 기타 중요함!!
- 엔티티에 의미 있는 메서드를 만들어서 어디서 변경되는지 알아야함 -> setter를 쓰지 말자!!
- 머지쓰지마라!! 변경감지써라!!
- 영속성 유지가 중요하다. 그래서 밖에서 조회하는 것 보다는 서비스에서 @Transactional 안에서 레포지토리를 통해서 아이템 멤버를 찾는다.
- 그렇게 되면 좋은점이 다른 값들이 바뀌더라도 영속성 안의 상태니깐 더티체킹이 됨
- 